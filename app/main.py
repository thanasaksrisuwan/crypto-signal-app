from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
import uvicorn
import json
import asyncio
from datetime import datetime
import sys

# Ensure the app directory is in the Python path
import os
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÇ‡∏°‡∏î‡∏π‡∏•‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏ß‡∏î‡∏•‡πâ‡∏≠‡∏°
import os
import sys
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, current_dir)
import env_manager as env

# ‡πÉ‡∏ä‡πâ RedisManager ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Redis client ‡πÅ‡∏¢‡∏Å
from redis_manager import get_redis_client, check_redis_connection

# ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ñ‡∏•‡∏≤‡∏™‡πÅ‡∏•‡∏∞‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ
from binance_ws_client import BinanceWebSocketClient
from signal_processor import SignalProcessor, grade_signal
from notification_service import NotificationService
from enhanced_memory_monitor import enhanced_memory_monitor

# ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Ñ‡∏£‡∏¥‡∏õ‡πÇ‡∏ï‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏ß‡∏î‡∏•‡πâ‡∏≠‡∏°
SYMBOLS = env.get_available_symbols()

# ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Redis
redis_config = env.get_redis_config()
REDIS_SIGNAL_CHANNEL = "crypto_signals:signals"
REDIS_KLINE_CHANNEL_PREFIX = "crypto_signals:kline:"

# ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÅ‡∏≠‡∏û‡∏û‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡∏ô FastAPI
app = FastAPI(
    title="Crypto Signal API",
    description="API for crypto trading signals based on 2-minute OHLCV data",
    version="0.1.0",
)

# ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ CORS ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ Frontend ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ API ‡πÑ‡∏î‡πâ
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ú‡∏•‡∏¥‡∏ï‡∏à‡∏£‡∏¥‡∏á‡∏Ñ‡∏ß‡∏£‡∏£‡∏∞‡∏ö‡∏∏ origins ‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì
class Signal(BaseModel):
    symbol: str
    timestamp: int
    forecast_pct: float
    confidence: float
    category: str  # strong buy, weak buy, hold, weak sell, strong sell
    price: Optional[float] = None
    indicators: Optional[Dict[str, Optional[float]]] = None

# ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤ Pydantic models ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ
class SymbolRequest(BaseModel):
    symbol: str

class SymbolResponse(BaseModel):
    success: bool
    message: str
    symbols: List[str]

# ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Redis
redis_connected = False
redis_client = None

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Redis ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
def connect_to_redis():
    global redis_client, redis_connected
    try:
        # ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Redis ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ connection pool
        redis_client = get_redis_client(decode_responses=True)
        # ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
        redis_connected = redis_client.ping()
        if redis_connected:
            print(f"‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Redis ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏ó‡∏µ‡πà {REDIS_HOST}:{REDIS_PORT}")
        return redis_connected
    except Exception as e:
        print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Redis: {e}")
        redis_connected = False
        return False

# ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Redis
connect_to_redis()

# ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥
enhanced_memory_monitor.start()

# ‡πÉ‡∏ä‡πâ OptimizedSignalProcessor ‡πÅ‡∏ó‡∏ô SignalProcessor ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô
from optimized_signal_processor import signal_processor

# ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á
def create_empty_signal(symbol: str) -> dict:
    return {
        "symbol": symbol,
        "timestamp": int(datetime.now().timestamp() * 1000),
        "forecast_pct": 0.0,
        "confidence": 0.0,
        "category": "no data",
        "price": 0.0,
        "indicators": {
            "ema9": None,
            "ema21": None,
            "sma20": None,
            "rsi14": None
        }
    }

# ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WebSocket ‡∏à‡∏≤‡∏Å clients
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
        self.redis_pubsub = None
        self.task = None
        self.client_subscriptions = {}  # ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ client
        self.heartbeat_task = None  # ‡πÄ‡∏û‡∏¥‡πà‡∏° task ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö heartbeat

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
        self.client_subscriptions[websocket] = set()  # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏ã‡πá‡∏ï‡∏ß‡πà‡∏≤‡∏á
        print(f"üì° WebSocket client ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß - ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: {len(self.active_connections)}")
        
        # ‡πÄ‡∏£‡∏¥‡πà‡∏° Redis PubSub ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÅ‡∏•‡∏∞ Redis ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ
        if self.redis_pubsub is None and redis_connected:
            try:
                self.redis_pubsub = redis_client.pubsub()
                self.redis_pubsub.subscribe(REDIS_SIGNAL_CHANNEL)
                # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡∏°‡πà
                self.task = asyncio.create_task(self.listen_for_messages())
                print(f"üì¢ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Redis PubSub listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡πà‡∏≠‡∏á {REDIS_SIGNAL_CHANNEL}")
            except Exception as e:
                print(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏° Redis PubSub ‡πÑ‡∏î‡πâ: {e}")
        
        # ‡πÄ‡∏£‡∏¥‡πà‡∏° heartbeat task ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ
        if self.heartbeat_task is None:
            self.heartbeat_task = asyncio.create_task(self.send_heartbeats())
            print("üíì ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô heartbeat system ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WebSocket")

    def disconnect(self, websocket: WebSocket):
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)
            # ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏Ç‡∏≠‡∏á client ‡∏ô‡∏µ‡πâ
            if websocket in self.client_subscriptions:
                del self.client_subscriptions[websocket]
            print(f"üîå WebSocket client ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß - ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠: {len(self.active_connections)}")
            
            # ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà ‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏∏‡∏î PubSub
            if not self.active_connections:
                if self.task:
                    self.task.cancel()
                if self.redis_pubsub:
                    try:
                        self.redis_pubsub.unsubscribe()
                    except Exception as e:
                        print(f"‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å Redis PubSub ‡πÑ‡∏î‡πâ: {e}")
                self.redis_pubsub = None
                self.task = None
                print("üì¢ ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å Redis PubSub listener ‡πÅ‡∏•‡πâ‡∏ß")
                
                # ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å heartbeat task
                if self.heartbeat_task:
                    self.heartbeat_task.cancel()
                    self.heartbeat_task = None
                    print("üíì ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å heartbeat system")

    async def broadcast(self, message: str):
        try:
            message_data = json.loads(message)
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á WebSockets ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏•‡∏ö‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î
            disconnected_websockets = []
            
            for connection in self.active_connections:
                try:
                    await connection.send_json(message_data)
                except RuntimeError as e:
                    if "Cannot call 'send' once a close message has been sent" in str(e):
                        print(f"‚ö†Ô∏è ‡∏û‡∏ö WebSocket ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£ broadcast - ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏•‡∏ö")
                        disconnected_websockets.append(connection)
                    else:
                        raise
                except Exception as e:
                    print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ broadcast ‡πÑ‡∏õ‡∏¢‡∏±‡∏á client: {e}")
                    if "WebSocket is not connected" in str(e):
                        disconnected_websockets.append(connection)
            
            # ‡∏•‡∏ö WebSockets ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ active_connections
            for ws in disconnected_websockets:
                if ws in self.active_connections:
                    self.disconnect(ws)
            
            if self.active_connections:  # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ connections ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                print(f"üì¢ ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á WebSocket clients ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î {len(self.active_connections)} ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠")
        except Exception as e:
            print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á clients: {e}")
    
    async def send_to_client(self, websocket: WebSocket, message: Dict):
        """‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á client ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏≤‡∏¢"""
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ websocket ‡∏¢‡∏±‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡πÅ‡∏•‡∏∞‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ active_connections
            if websocket in self.active_connections:
                try:
                    # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á client
                    await websocket.send_json(message)
                    print(f"üì® ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á WebSocket client ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏≤‡∏¢")
                except RuntimeError as e:
                    if "Cannot call 'send' once a close message has been sent" in str(e):
                        print(f"‚ö†Ô∏è WebSocket ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° - ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£")
                        # ‡πÄ‡∏≠‡∏≤‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å active_connections ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏ã‡πâ‡∏≥
                        if websocket in self.active_connections:
                            self.disconnect(websocket)
                    else:
                        raise
            else:
                print("‚ö†Ô∏è ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á WebSocket ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß - ‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á")
        except Exception as e:
            print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á client: {e}")
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            if "WebSocket is not connected" in str(e) and websocket in self.active_connections:
                print("‚ö†Ô∏è ‡∏û‡∏ö WebSocket ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ active_connections - ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏•‡∏ö‡∏≠‡∏≠‡∏Å")
                self.disconnect(websocket)
    
    async def listen_for_messages(self):
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å Redis PubSub ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á clients"""
        try:
            while True:
                if not redis_connected or self.redis_pubsub is None:
                    print("‚ö†Ô∏è Redis ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ - ‡∏£‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏à‡∏∞‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á")
                    await asyncio.sleep(5)
                    # ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Redis ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
                    if connect_to_redis() and redis_connected:
                        try:
                            self.redis_pubsub = redis_client.pubsub()
                            self.redis_pubsub.subscribe(REDIS_SIGNAL_CHANNEL)
                            print(f"üì¢ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Redis PubSub listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡πà‡∏≠‡∏á {REDIS_SIGNAL_CHANNEL} ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á")
                        except Exception as e:
                            print(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏° Redis PubSub ‡πÑ‡∏î‡πâ: {e}")
                    continue
                    
                try:
                    message = self.redis_pubsub.get_message(ignore_subscribe_messages=True)
                    if message and message['type'] == 'message':
                        print(f"üì¨ ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å Redis ‡∏ä‡πà‡∏≠‡∏á {message.get('channel')}")
                        await self.broadcast(message['data'])
                except redis.RedisError as e:
                    print(f"‚ö†Ô∏è ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î Redis ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°: {e}")
                    await asyncio.sleep(5)  # ‡∏£‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
                except Exception as e:
                    print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°: {e}")
                
                await asyncio.sleep(0.01)  # ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ CPU
        except asyncio.CancelledError:
            # ‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß
            print("üõë Redis listener ‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å")
        except Exception as e:
            print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô WebSocket listener: {e}")
            
    async def send_heartbeats(self):
        """‡∏™‡πà‡∏á heartbeat ‡πÑ‡∏õ‡∏¢‡∏±‡∏á clients ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠"""
        try:
            while True:
                disconnected_websockets = []
                
                for connection in self.active_connections:
                    try:
                        # ‡∏™‡πà‡∏á heartbeat ‡∏ó‡∏∏‡∏Å 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
                        await connection.send_json({"type": "heartbeat", "timestamp": int(datetime.now().timestamp())})
                    except Exception as e:
                        # ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡πÑ‡∏î‡πâ ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤ connection ‡∏≠‡∏≤‡∏à‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
                        print(f"‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á heartbeat ‡πÑ‡∏î‡πâ: {e}")
                        disconnected_websockets.append(connection)
                
                # ‡∏•‡∏ö connections ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á heartbeat ‡πÑ‡∏î‡πâ
                for ws in disconnected_websockets:
                    if ws in self.active_connections:
                        self.disconnect(ws)
                
                if self.active_connections and not disconnected_websockets:
                    print(f"üíì ‡∏™‡πà‡∏á heartbeat ‡πÑ‡∏õ‡∏¢‡∏±‡∏á {len(self.active_connections)} connections")
                
                # ‡∏£‡∏≠ 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á heartbeat ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ï‡πà‡∏≠‡πÑ‡∏õ
                await asyncio.sleep(30)
        except asyncio.CancelledError:
            print("üíì ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å heartbeat task")
        except Exception as e:
            print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô heartbeat system: {e}")
            # ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó heartbeat task
            await asyncio.sleep(10)
            if self.active_connections:
                self.heartbeat_task = asyncio.create_task(self.send_heartbeats())
                print("üíì ‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó heartbeat system")

# ‡∏™‡∏£‡πâ‡∏≤‡∏á Connection Manager
manager = ConnectionManager()

@app.get("/")
async def root():
    """
    API endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ API ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á Redis
    """
    if not redis_connected:
        # ‡∏•‡∏≠‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Redis ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
        connect_to_redis()
        
    return {
        "status": "online",
        "message": "Crypto Signal API is running",
        "redis_status": "connected" if redis_connected else "disconnected",
        "available_symbols": SYMBOLS,
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/latest-signal")
async def get_latest_signal(symbol: str = "BTCUSDT"):
    if symbol not in SYMBOLS:
        raise HTTPException(status_code=404, detail=f"No data for symbol {symbol}")
    
    try:
        if not redis_connected:
            raise HTTPException(status_code=503, detail="Redis service unavailable")
            
        latest_signal = redis_client.get(f"latest_signal:{symbol}")
        
        if not latest_signal:
            return create_empty_signal(symbol)
        
        return json.loads(latest_signal)
    except redis.RedisError as e:
        print(f"‚ö†Ô∏è Redis error: {e}")
        raise HTTPException(status_code=503, detail="Redis service error")
    except Exception as e:
        print(f"‚ùå Error fetching latest signal: {e}")
        raise HTTPException(status_code=500, detail=f"Error fetching latest signal: {str(e)}")

@app.get("/api/history-signals")
async def get_history_signals(symbol: str = "BTCUSDT", limit: int = 10):
    if symbol not in SYMBOLS:
        raise HTTPException(status_code=404, detail=f"No data for symbol {symbol}")
    
    try:
        if not redis_connected:
            raise HTTPException(status_code=503, detail="Redis service unavailable")
            
        signals = redis_client.lrange(f"signal_history:{symbol}", 0, limit - 1)
        
        if not signals or len(signals) == 0:
            return []  # Return empty array if no signals found
        
        return [json.loads(signal) for signal in signals]
    except redis.RedisError as e:
        print(f"‚ö†Ô∏è Redis error: {e}")
        raise HTTPException(status_code=503, detail="Redis service error")
    except Exception as e:
        print(f"‚ùå Error fetching signal history: {e}")
        raise HTTPException(status_code=500, detail=f"Error fetching signal history: {str(e)}")

@app.get("/available-symbols")
async def get_available_symbols():
    """‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£"""
    return {"symbols": SYMBOLS}

@app.get("/latest-indicators")
async def get_latest_indicators(symbol: str = "BTCUSDT"):
    if symbol not in SYMBOLS:
        raise HTTPException(status_code=404, detail=f"No data for symbol {symbol}")
    
    try:
        if not redis_connected:
            raise HTTPException(status_code=503, detail="Redis service unavailable")
        
        latest_signal = redis_client.get(f"latest_signal:{symbol}")
        
        if not latest_signal:
            empty = create_empty_signal(symbol)
            return {"symbol": symbol, "indicators": empty["indicators"]}
        
        signal_data = json.loads(latest_signal)
        
        if 'indicators' in signal_data:
            return {"symbol": symbol, "indicators": signal_data['indicators']}
        else:
            empty = create_empty_signal(symbol)
            return {"symbol": symbol, "indicators": empty["indicators"]}
    except redis.RedisError as e:
        print(f"‚ö†Ô∏è Redis error: {e}")
        raise HTTPException(status_code=503, detail="Redis service error")
    except Exception as e:
        print(f"‚ùå Error fetching latest indicators: {e}")
        raise HTTPException(status_code=500, detail=f"Error fetching latest indicators: {str(e)}")

# API endpoints ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Ñ‡∏£‡∏¥‡∏õ‡πÇ‡∏ï
@app.get("/api/symbols", response_model=SymbolResponse)
async def get_symbols():
    """
    ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    
    Returns:
        ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Ñ‡∏£‡∏¥‡∏õ‡πÇ‡∏ï‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
    """
    try:
        symbols = env.get_available_symbols()
        return SymbolResponse(
            success=True,
            message=f"‡∏û‡∏ö {len(symbols)} ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå",
            symbols=symbols
        )
    except Exception as e:
        return SymbolResponse(
            success=False,
            message=f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {str(e)}",
            symbols=[]
        )

@app.post("/api/symbols/add", response_model=SymbolResponse)
async def add_symbol(request: SymbolRequest, background_tasks: BackgroundTasks):
    """
    ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Ñ‡∏£‡∏¥‡∏õ‡πÇ‡∏ï‡πÉ‡∏´‡∏°‡πà
    
    Args:
        request: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°
        
    Returns:
        ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß
    """
    try:
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå
        symbol = request.symbol.strip().upper()
        if not symbol.endswith("USDT"):
            return SymbolResponse(
                success=False,
                message="‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ï‡πâ‡∏≠‡∏á‡∏•‡∏á‡∏ó‡πâ‡∏≤‡∏¢‡∏î‡πâ‡∏ß‡∏¢ USDT",
                symbols=env.get_available_symbols()
            )
        
        # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡πÉ‡∏´‡∏°‡πà
        success = env.add_symbol(symbol)
        
        # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡πÉ‡∏´‡πâ‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó Binance WebSocket client
        if success:
            # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÉ‡∏ô‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÅ‡∏≠‡∏õ‡∏û‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡∏ô
            global SYMBOLS
            SYMBOLS = env.get_available_symbols()
            
            # ‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó WebSocket client ‡πÉ‡∏ô background task
            background_tasks.add_task(restart_websocket_client)
            
            return SymbolResponse(
                success=True,
                message=f"‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå {symbol} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡πÅ‡∏•‡∏∞‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°",
                symbols=SYMBOLS
            )
        else:
            return SymbolResponse(
                success=False,
                message=f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå {symbol} ‡πÑ‡∏î‡πâ (‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß)",
                symbols=env.get_available_symbols()
            )
            
    except Exception as e:
        return SymbolResponse(
            success=False,
            message=f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {str(e)}",
            symbols=env.get_available_symbols()
        )

@app.post("/api/symbols/remove", response_model=SymbolResponse)
async def remove_symbol(request: SymbolRequest, background_tasks: BackgroundTasks):
    """
    ‡∏•‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Ñ‡∏£‡∏¥‡∏õ‡πÇ‡∏ï‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
    
    Args:
        request: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏•‡∏ö
        
    Returns:
        ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡πÅ‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß
    """
    try:
        symbol = request.symbol.strip().upper()
        success = env.remove_symbol(symbol)
        
        # ‡∏ñ‡πâ‡∏≤‡∏•‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡πÉ‡∏´‡πâ‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó Binance WebSocket client
        if success:
            # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÉ‡∏ô‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÅ‡∏≠‡∏õ‡∏û‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡∏ô
            global SYMBOLS
            SYMBOLS = env.get_available_symbols()
            
            # ‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó WebSocket client ‡πÉ‡∏ô background task
            background_tasks.add_task(restart_websocket_client)
            
            return SymbolResponse(
                success=True,
                message=f"‡∏•‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå {symbol} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
                symbols=SYMBOLS
            )
        else:
            return SymbolResponse(
                success=False,
                message=f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå {symbol} ‡πÑ‡∏î‡πâ (‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢)",
                symbols=env.get_available_symbols()
            )
            
    except Exception as e:
        return SymbolResponse(
            success=False,
            message=f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {str(e)}",
            symbols=env.get_available_symbols()
        )

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó WebSocket client
async def restart_websocket_client():
    """‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó Binance WebSocket client ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°"""
    try:
        # ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WebSocket ‡πÄ‡∏î‡∏¥‡∏° (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
        if hasattr(app, 'ws_client') and app.ws_client:
            await app.ws_client.close()
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏ô‡∏™‡πÅ‡∏ï‡∏ô‡∏ã‡πå‡πÉ‡∏´‡∏°‡πà‡∏î‡πâ‡∏ß‡∏¢‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß
        app.ws_client = BinanceWebSocketClient(SYMBOLS)
        
        # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏£‡∏≤‡∏Ñ‡∏≤‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∑‡πà‡∏ô ‡πÜ
        asyncio.create_task(app.ws_client.start_kline_streams())
        
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
        logger.info(f"‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó WebSocket client ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏Å‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå: {', '.join(SYMBOLS)}")
        
    except Exception as e:
        logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó WebSocket client: {e}")

@app.websocket("/ws/signals")
async def websocket_endpoint(websocket: WebSocket):
    """
    WebSocket endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≤‡∏¢‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå
    """
    try:
        # ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
        await manager.connect(websocket)
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ WebSocket ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà
        try:
            while True:
                try:
                    # ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å client ‡∏î‡πâ‡∏ß‡∏¢ timeout
                    data = await asyncio.wait_for(websocket.receive_text(), timeout=60.0)
                    
                    try:
                        client_message = json.loads(data)
                        print(f"üì© ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å WebSocket client: {client_message}")
                        
                        # ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö pong ‡∏à‡∏≤‡∏Å client
                        if client_message.get('type') == 'pong':
                            print(f"üíì ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö pong ‡∏à‡∏≤‡∏Å client ‡πÄ‡∏ß‡∏•‡∏≤ {datetime.fromtimestamp(client_message.get('timestamp', 0)).strftime('%H:%M:%S')}")
                            continue
                        
                        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å
                        if 'subscribe' in client_message:
                            symbol = client_message['subscribe']
                            print(f"üëÇ Client ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {symbol}")
                            
                            # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏Ç‡∏≠‡∏á client ‡∏ô‡∏µ‡πâ
                            if websocket in manager.client_subscriptions:
                                manager.client_subscriptions[websocket].add(symbol)
                            
                            if symbol in SYMBOLS and websocket in manager.active_connections:
                                try:
                                    # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
                                    latest_signal = redis_client.get(f"latest_signal:{symbol}")
                                    if latest_signal:
                                        await manager.send_to_client(websocket, json.loads(latest_signal))
                                    else:
                                        mock_data = create_empty_signal(symbol)
                                        await manager.send_to_client(websocket, mock_data)
                                except WebSocketDisconnect:
                                    raise
                                except Exception as e:
                                    print(f"‚ö†Ô∏è ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {symbol}: {e}")

                    except json.JSONDecodeError:
                        print("‚ö†Ô∏è ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà JSON ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏≤‡∏Å client")
                    except Exception as e:
                        print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å client: {e}")
                        if "WebSocket is not connected" in str(e):
                            raise WebSocketDisconnect()

                except asyncio.TimeoutError:
                    # ‡∏™‡πà‡∏á ping ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
                    try:
                        await websocket.send_json({"type": "ping", "timestamp": int(datetime.now().timestamp())})
                    except Exception:
                        raise WebSocketDisconnect()
                    continue

                except WebSocketDisconnect:
                    raise

        except WebSocketDisconnect:
            print("üîå WebSocket client ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠")
        finally:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ websocket ‡∏¢‡∏±‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ active_connections ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏Å disconnect
            if websocket in manager.active_connections:
                manager.disconnect(websocket)

    except Exception as e:
        print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏‡πÉ‡∏ô WebSocket endpoint: {e}")
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ websocket ‡∏¢‡∏±‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ active_connections ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏Å disconnect
        if websocket in manager.active_connections:
            manager.disconnect(websocket)

@app.websocket("/ws/depth/{symbol}")
async def depth_websocket_endpoint(websocket: WebSocket, symbol: str):
    """
    WebSocket endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• orderbook depth ‡∏Ç‡∏≠‡∏á‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
    - ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• mock ‡πÉ‡∏ô‡∏≠‡∏±‡∏ï‡∏£‡∏≤ 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á/‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ frontend ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
    """
    try:
        # ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
        await websocket.accept()
        print(f"WebSocket connection accepted for depth/{symbol}")
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ô‡∏µ‡πâ‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if symbol.upper() not in SYMBOLS:
            await websocket.send_json({
                "error": f"Symbol {symbol} not supported. Available symbols are: {', '.join(SYMBOLS)}"
            })
            await websocket.close()
            return
        
        try:
            # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏ó‡∏∏‡∏Å‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            while True:
                try:
                    # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏•‡∏≠‡∏á
                    mock_data = {
                        "symbol": symbol.upper(),
                        "lastUpdateId": int(datetime.now().timestamp() * 1000),
                        "bids": [
                            [str(30000 - i * 10), str(1.0 / (i + 1))] for i in range(5)
                        ],
                        "asks": [
                            [str(30000 + i * 10), str(1.0 / (i + 1))] for i in range(5)
                        ],
                        "timestamp": int(datetime.now().timestamp() * 1000)
                    }
                    
                    # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á client
                    await websocket.send_json(mock_data)
                    
                    # ‡∏£‡∏≠‡∏î‡∏π‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å client ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                    try:
                        client_msg = await asyncio.wait_for(websocket.receive_text(), timeout=0.1)
                        try:
                            client_data = json.loads(client_msg)
                            if client_data.get('type') == 'pong':
                                print(f"Received pong from client for depth/{symbol}")
                        except json.JSONDecodeError:
                            pass
                    except asyncio.TimeoutError:
                        pass
                    
                    # ‡∏£‡∏≠ 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
                    await asyncio.sleep(1.0)
                    
                except asyncio.CancelledError:
                    print(f"Task for depth/{symbol} was cancelled")
                    break
                    
        except WebSocketDisconnect:
            print(f"WebSocket client for depth/{symbol} disconnected")
        except Exception as e:
            print(f"Error handling depth WebSocket for {symbol}: {e}")
            
    except Exception as e:
        print(f"Error in depth WebSocket endpoint for {symbol}: {e}")
        try:
            await websocket.close()
        except:
            pass

@app.websocket("/ws/trades/{symbol}")
async def trades_websocket_endpoint(websocket: WebSocket, symbol: str):
    """
    WebSocket endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≤‡∏¢‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
    - ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• mock ‡∏ó‡∏∏‡∏Å 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ frontend ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
    """
    try:
        # ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
        await websocket.accept()
        print(f"WebSocket connection accepted for trades/{symbol}")
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ô‡∏µ‡πâ‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if symbol.upper() not in SYMBOLS:
            await websocket.send_json({
                "error": f"Symbol {symbol} not supported. Available symbols are: {', '.join(SYMBOLS)}"
            })
            await websocket.close()
            return
        
        try:
            import random
            
            # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏ó‡∏∏‡∏Å 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            while True:
                try:
                    # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏£‡∏≤‡∏Ñ‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤ Bitcoin)
                    base_price = 30000 + random.randint(-50, 50)
                    
                    # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≤‡∏¢‡∏à‡∏≥‡∏•‡∏≠‡∏á
                    is_buyer_maker = random.choice([True, False])
                    mock_trade = {
                        "e": "trade",
                        "E": int(datetime.now().timestamp() * 1000),
                        "s": symbol.upper(),
                        "t": int(datetime.now().timestamp() * 1000000),
                        "p": str(base_price),
                        "q": str(round(random.uniform(0.001, 0.1), 6)),
                        "b": 123456,
                        "a": 123457,
                        "T": int(datetime.now().timestamp() * 1000),
                        "m": is_buyer_maker,
                        "M": True
                    }
                    
                    # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á client
                    await websocket.send_json(mock_trade)
                    
                    # ‡∏£‡∏≠ 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
                    await asyncio.sleep(2.0)
                    
                except asyncio.CancelledError:
                    print(f"Task for trades/{symbol} was cancelled")
                    break
                    
        except WebSocketDisconnect:
            print(f"WebSocket client for trades/{symbol} disconnected")
        except Exception as e:
            print(f"Error handling trades WebSocket for {symbol}: {e}")
            
    except Exception as e:
        print(f"Error in trades WebSocket endpoint for {symbol}: {e}")
        try:
            await websocket.close()
        except:
            pass

@app.websocket("/ws/kline/{symbol}")
async def kline_websocket_endpoint(websocket: WebSocket, symbol: str):
    """
    WebSocket endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• kline (‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô) ‡∏Ç‡∏≠‡∏á‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
    - ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• mock ‡∏ó‡∏∏‡∏Å 1 ‡∏ô‡∏≤‡∏ó‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ frontend ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
    """
    try:
        # ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
        await websocket.accept()
        print(f"WebSocket connection accepted for kline/{symbol}")
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ô‡∏µ‡πâ‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if symbol.upper() not in SYMBOLS:
            await websocket.send_json({
                "error": f"Symbol {symbol} not supported. Available symbols are: {', '.join(SYMBOLS)}"
            })
            await websocket.close()
            return
        
        import random
        
        # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥
        base_price = 30000
        current_time = int(datetime.now().timestamp() * 1000) - (60 * 60 * 1000)  # 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏Å‡πà‡∏≠‡∏ô
        interval = 60 * 1000  # 1 ‡∏ô‡∏≤‡∏ó‡∏µ
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á 60 ‡πÅ‡∏ó‡πà‡∏á
        historical_data = []
        for i in range(60):
            price_change = random.uniform(-100, 100)
            open_price = base_price + price_change
            close_price = open_price + random.uniform(-50, 50)
            high_price = max(open_price, close_price) + random.uniform(5, 20)
            low_price = min(open_price, close_price) - random.uniform(5, 20)
            volume = random.uniform(5, 20)
            
            candle = {
                "timestamp": current_time + (i * interval),
                "open": str(open_price),
                "high": str(high_price),
                "low": str(low_price),
                "close": str(close_price),
                "volume": str(volume)
            }
            historical_data.append(candle)
            base_price = float(close_price)
        
        # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÑ‡∏õ‡∏¢‡∏±‡∏á client
        await websocket.send_json({
            "type": "kline_history",
            "symbol": symbol.upper(),
            "data": historical_data
        })
        
        # ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
        latest_price = float(historical_data[-1]["close"])
        latest_timestamp = historical_data[-1]["timestamp"]
        
        try:
            # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å 1 ‡∏ô‡∏≤‡∏ó‡∏µ
            while True:
                try:
                    # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡∏∞‡∏£‡∏≤‡∏Ñ‡∏≤
                    latest_timestamp += interval
                    price_change = random.uniform(-50, 50)
                    open_price = latest_price
                    close_price = open_price + price_change
                    high_price = max(open_price, close_price) + random.uniform(5, 20)
                    low_price = min(open_price, close_price) - random.uniform(5, 20)
                    volume = random.uniform(5, 20)
                    
                    # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• kline ‡πÉ‡∏´‡∏°‡πà
                    new_candle = {
                        "timestamp": latest_timestamp,
                        "open": str(open_price),
                        "high": str(high_price),
                        "low": str(low_price),
                        "close": str(close_price),
                        "volume": str(volume)
                    }
                    
                    # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á client
                    await websocket.send_json({
                        "type": "kline",
                        "symbol": symbol.upper(),
                        "data": new_candle
                    })
                    
                    # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏£‡∏≤‡∏Ñ‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
                    latest_price = close_price
                    
                    # ‡∏£‡∏≠ 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤ (‡∏à‡∏£‡∏¥‡∏á ‡πÜ ‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô 1 ‡∏ô‡∏≤‡∏ó‡∏µ)
                    await asyncio.sleep(5.0)
                    
                except asyncio.CancelledError:
                    print(f"Task for kline/{symbol} was cancelled")
                    break
                    
        except WebSocketDisconnect:
            print(f"WebSocket client for kline/{symbol} disconnected")
        except Exception as e:
            print(f"Error handling kline WebSocket for {symbol}: {e}")
            
    except Exception as e:
        print(f"Error in kline WebSocket endpoint for {symbol}: {e}")
        try:
            await websocket.close()
        except:
            pass

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Binance WebSocket Client ‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á
async def start_binance_client():
    """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Binance WebSocket client ‡πÅ‡∏•‡∏∞‡∏ü‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•"""
    max_retries = 5
    retry_count = 0
    
    while retry_count < max_retries:
        try:
            print("üöÄ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Binance WebSocket client...")
            client = BinanceWebSocketClient()
            connected = await client.connect()
            
            if connected and client.is_running:
                print("‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Binance WebSocket ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
                await client.start_kline_streams()
                
                # ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
                while client.is_running:
                    await asyncio.sleep(60)
            else:
                print("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Binance WebSocket ‡πÑ‡∏î‡πâ")
                await asyncio.sleep(10)  # ‡∏£‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
                retry_count += 1
        except asyncio.CancelledError:
            print("üõë ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á Binance client")
            break
        except Exception as e:
            print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô Binance client: {e}")
            await asyncio.sleep(10)  # ‡∏£‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
            retry_count += 1
        finally:
            try:
                if 'client' in locals() and client:
                    await client.close()
            except Exception as e:
                print(f"‚ö†Ô∏è ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î Binance client: {e}")
    
    print("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Binance client ‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏ã‡πâ‡∏≥‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á")

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• kline ‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì
async def process_kline_data():
    """‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• kline ‡∏à‡∏≤‡∏Å Redis PubSub ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì"""
    if not redis_connected:
        print("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏£‡∏∞‡∏ö‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• kline ‡πÑ‡∏î‡πâ - Redis ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠")
        return
    
    try:
        pubsub = redis_client.pubsub()
        
        # ‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏ä‡πà‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå
        for symbol in SYMBOLS:
            channel = f"{REDIS_KLINE_CHANNEL_PREFIX}{symbol}:2m"
            pubsub.subscribe(channel)
            print(f"üëÇ ‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å Redis ‡∏ä‡πà‡∏≠‡∏á {channel}")
        
        while True:
            if not redis_connected:
                print("‚ö†Ô∏è Redis ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ - ‡∏´‡∏¢‡∏∏‡∏î‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• kline ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß")
                await asyncio.sleep(10)
                continue
                
            try:
                message = pubsub.get_message(ignore_subscribe_messages=True)
                
                if message and message['type'] == 'message':
                    try:
                        # ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô JSON
                        data = json.loads(message['data'])
                        
                        # ‡∏î‡∏∂‡∏á‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏ä‡πà‡∏≠‡∏á
                        channel = message['channel']
                        channel_str = channel if isinstance(channel, str) else channel.decode()
                        parts = channel_str.split(':')
                        
                        # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏ä‡πà‡∏≠‡∏á
                        if len(parts) >= 3:
                            symbol = parts[2].split(":")[0]  # ‡∏î‡∏∂‡∏á‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏ä‡πà‡∏≠‡∏á
                            
                            # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ symbol ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô SYMBOLS ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                            if symbol in SYMBOLS:
                                # ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì
                                print(f"üìä ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• kline ‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {symbol}")
                                signal = signal_processor.process_market_data(symbol, data)
                                
                                if signal:
                                    print(f"üìä ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡πÉ‡∏´‡∏°‡πà: {signal['category']} ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {symbol}")
                                    
                                    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏õ‡∏¢‡∏±‡∏á Redis ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                                    try:
                                        latest_signal = redis_client.get(f"latest_signal:{symbol}")
                                        if latest_signal:
                                            print(f"‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {symbol} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
                                        else:
                                            print(f"‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {symbol}")
                                    except Exception as e:
                                        print(f"‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÑ‡∏î‡πâ: {e}")
                            else:
                                print(f"‚ö†Ô∏è ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å: {symbol}")
                        else:
                            print(f"‚ö†Ô∏è ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ä‡πà‡∏≠‡∏á Redis ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: {channel_str}")
                            
                    except json.JSONDecodeError as e:
                        print(f"‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô JSON ‡πÑ‡∏î‡πâ: {e}")
                    except Exception as e:
                        print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°: {e}")
            except redis.RedisError as e:
                print(f"‚ö†Ô∏è ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î Redis ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°: {e}")
                await asyncio.sleep(5)  # ‡∏£‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
            except Exception as e:
                print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°: {e}")
                await asyncio.sleep(5)  # ‡∏£‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
            
            await asyncio.sleep(0.01)  # ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ CPU
    except asyncio.CancelledError:
        # ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏≠‡∏õ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î
        try:
            pubsub.unsubscribe()
        except Exception as e:
            print(f"‚ö†Ô∏è ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å: {e}")
        print("üõë ‡∏Å‡∏£‡∏∞‡∏ö‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• kline ‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å")
    except Exception as e:
        print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: {e}")
        try:
            pubsub.unsubscribe()
        except Exception as unsub_err:
            print(f"‚ö†Ô∏è ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å: {unsub_err}")

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Notification Service ‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á
async def start_notification_service():
    """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á"""
    if not redis_connected:
        print("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÑ‡∏î‡πâ - Redis ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠")
        return
        
    try:
        print("üì± ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô...")
        notification_service = NotificationService()
        
        try:
            pubsub = notification_service.pubsub
            print("üëÇ ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ü‡∏±‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°...")
            
            while True:
                if not redis_connected:
                    print("‚ö†Ô∏è Redis ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ - ‡∏´‡∏¢‡∏∏‡∏î‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß")
                    await asyncio.sleep(10)
                    continue
                    
                try:
                    message = pubsub.get_message(ignore_subscribe_messages=True)
                    if message:
                        print(f"üì£ ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô")
                        notification_service.process_message(message)
                except redis.RedisError as e:
                    print(f"‚ö†Ô∏è ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î Redis ‡πÉ‡∏ô‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: {e}")
                    await asyncio.sleep(5)
                    
                await asyncio.sleep(0.01)  # ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ CPU
        except Exception as e:
            print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: {e}")
    except Exception as e:
        print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: {e}")
    finally:
        try:
            if 'pubsub' in locals():
                pubsub.unsubscribe()
        except Exception as e:
            print(f"‚ö†Ô∏è ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏Ç‡∏≠‡∏á‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: {e}")

@app.on_event("startup")
async def startup_event():
    """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏á‡∏≤‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏≠‡∏õ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô"""
    global redis_connected
    
    print("üöÄ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô API server...")
    
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Redis ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
    if not redis_connected:
        redis_connected = connect_to_redis()
    
    # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Binance WebSocket
    asyncio.create_task(start_binance_client())
    print("‚úÖ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô task Binance WebSocket client ‡πÅ‡∏•‡πâ‡∏ß")
    
    # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì
    asyncio.create_task(process_kline_data())
    print("‚úÖ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô task ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• kline ‡πÅ‡∏•‡πâ‡∏ß")
    
    # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
    asyncio.create_task(start_notification_service())
    print("‚úÖ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô task ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÅ‡∏•‡πâ‡∏ß")
    
    print("üåü API server ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå")

@app.on_event("shutdown")
async def shutdown_event():
    """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡πÅ‡∏≠‡∏õ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏∞‡∏≠‡∏≤‡∏î"""
    # ‡∏ó‡∏≤‡∏™‡∏Ñ‡∏á‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏≠‡∏õ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î
    print("‚èπÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î‡πÅ‡∏≠‡∏õ...")

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)